<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">

	<title>Workers - MZBench Docs</title>

        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome-4.0.3.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="../css/highlight.css">
        <link href="../css/custom.css" rel="stylesheet">

        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->

        
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">

        <!-- Collapsed navigation -->
        <div class="navbar-header">
            
            <!-- Expander button -->
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            

            <!-- Main title -->
            <a class="navbar-brand" href="..">MZBench Docs</a>
        </div>

        <!-- Expanded navigation -->
        <div class="navbar-collapse collapse">
            
                <!-- Main navigation -->
                <ul class="nav navbar-nav">
                
                
                    <li >
                        <a href="..">Overview</a>
                    </li>
                
                
                
                    <li >
                        <a href="../scenarios/">Scenarios</a>
                    </li>
                
                
                
                    <li >
                        <a href="../cli/">CLI</a>
                    </li>
                
                
                
                    <li >
                        <a href="../api/">API</a>
                    </li>
                
                
                
                    <li >
                        <a href="../deployment/">Deployment</a>
                    </li>
                
                
                
                    <li >
                        <a href="../cloud_plugins/">Cloud Plugins</a>
                    </li>
                
                
                
                    <li class="active">
                        <a href="./">Workers</a>
                    </li>
                
                
                </ul>
            

            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                        <i class="fa fa-search"></i> Search
                    </a>
                </li>
                
                    <li >
                        <a rel="next" href="../cloud_plugins/">
                            <i class="fa fa-arrow-left"></i> Previous
                        </a>
                    </li>
                    <li class="disabled">
                        <a rel="prev" >
                            Next <i class="fa fa-arrow-right"></i>
                        </a>
                    </li>
                
                
                    <li>
                        <a href="http://github.com/machinezone/mzbench/">
                            
                                <i class="fa fa-github"></i>
                            
                            GitHub
                        </a>
                    </li>
                
            </ul>
        </div>
    </div>
</div>

        <div class="container">
            
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
    
        <li class="main active"><a href="#how-to-write-a-worker">How to Write a Worker</a></li>
        
            <li><a href="#command-line-utilities">Command Line Utilities</a></li>
        
            <li><a href="#general-worker-structure">General Worker Structure</a></li>
        
            <li><a href="#how-to-define-statements">How to Define Statements</a></li>
        
            <li><a href="#metrics">Metrics</a></li>
        
    
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<p>Today internet is a huge set of ever changing technologies. It would be impossible in practice for MZBench distribution to provide an extensive library of functions to access all the possible services and protocols. Instead, it uses a plugin system called <em>workers</em>.</p>
<p><strong>Worker</strong> is an Erlang application providing <a href="../scenarios/">statements</a> to access a particular service (such as HTTP or SSH server) and collecting statistics about its usage. Some workers are bundled with the distribution, but you will likely need to write your own to access the service you want to benchmark. This document is here to guide you through this process.</p>
<p>Because a worker is an Erlang application, you need basic knowledge of this programming language to understand this document. Refer to <a href="http://www.erlang.org/doc/getting_started/users_guide.html">Getting Started with Erlang User&rsquo;s Guide</a> or to the <a href="http://learnyousomeerlang.com">Learn You Some Erlang for great good!</a> book for an introduction to the matter.</p>
<h1 id="how-to-write-a-worker">How to Write a Worker<a class="headerlink" href="#how-to-write-a-worker" title="Permanent link">&para;</a></h1>
<h2 id="command-line-utilities">Command Line Utilities<a class="headerlink" href="#command-line-utilities" title="Permanent link">&para;</a></h2>
<p>MZBench distribution provides <a href="../cli/">command line utilities</a> to assist you during your development effort.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All command examples below are executed in the MZBench directory. To run them from a different location, specify the full path to MZBench:</p>
<pre><code>$ /path/to/mzbench/bin/mzbench
</code></pre>
</div>
<h3 id="generate">Generate<a class="headerlink" href="#generate" title="Permanent link">&para;</a></h3>
<p>First of all, generate an empty worker application with <a href="../cli/#new_worker"><code>new_worker</code></a>:</p>
<pre><code class="bash">$ ./bin/mzbench new_worker &lt;worker_name&gt;
</code></pre>

<p>It creates a new directory <code>&lt;worker_name&gt;</code> with a minimalistic but fully functional MZBench worker named <code>&lt;worker_name&gt;</code>. Particularly interesting files are <code>src/&lt;worker_name&gt;.erl</code>, which holds the worker source code, and <code>examples/&lt;worker_name&gt;.erl</code>, which contains a simple MZBench <a href="../scenarios/">scenario</a> using it.</p>
<p>If the service you develop a worker for is based on a well-known protocol like TCP, the <code>new_worker</code> command can generate your a more elaborate worker already containing the usual boilerplate code for this type of service. List available protocol templates with <a href="../cli/#list_templates"><code>list_templates</code></a>:</p>
<pre><code class="bash">$ ./bin/mzbench list_templates
</code></pre>

<p>Then generate your worker with the additional <code>--template</code> parameter:</p>
<pre><code class="bash">./bin/mzbench new_worker --template &lt;protocol&gt; &lt;worker_name&gt;
</code></pre>

<h3 id="compile-and-debug">Compile and Debug<a class="headerlink" href="#compile-and-debug" title="Permanent link">&para;</a></h3>
<p>During development, you&rsquo;ll need to do a lot of debugging. If you had to launch a complete benchmark every time you want to launch your test scenario, it would be cumbersome. MZBench provides a quicker way to build your worker and launch a local instance of your benchmarking scenario using it.</p>
<p>In the worker directory, run <a href="../cli/#run_local"><code>run_local &lt;script&gt;</code></a>, where <code>&lt;script&gt;</code> is the path to the scenario to run:</p>
<pre><code class="bash">$ ./bin/mzbench run_local &lt;script&gt;
</code></pre>

<p>You can define environment variables with the <code>--env</code> option.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All <a href="../scenarios/#make_install"><code>make_install</code></a> top-level statements are ignored in this execution mode.</p>
</div>
<h3 id="execute">Execute<a class="headerlink" href="#execute" title="Permanent link">&para;</a></h3>
<p>After you have done with the debugging, execute your worker in a cloud: Specify the worker git address in your benchmark scenario with <a href="../scenarios/#make_install"><code>{make_install, [{git, &lt;URL&gt;}, {branch, &lt;Branch&gt;}, {dir, &lt;Dir&gt;}]}</code></a>.</p>
<p><a href="../../workers/simple_http/examples/simple_http.erl">Simple HTTP worker example →</a></p>
<h2 id="general-worker-structure">General Worker Structure<a class="headerlink" href="#general-worker-structure" title="Permanent link">&para;</a></h2>
<p>A worker provides DSL statements and metrics. The statements need not to be independent as the worker can have internal state.</p>
<p>To understand the general structure of a worker, let&rsquo;s see the source code of the <code>dummy_worker</code> provided with the MZBench distribution:</p>
<pre><code class="erlang">-module(dummy_worker).
-export([initial_state/0, metrics/0,
         print/3]).

-include(&quot;mzb_types.hrl&quot;).

-type state() :: string().
-type meta() :: [{Key :: atom(), Value :: any()}].

-type graph_group() :: {group, Name :: string(), [graph()]}
                     | graph().
-type graph()       :: {graph, Opts :: #{metrics =&gt; [metric()],
                                         units =&gt; string(),
                                         title =&gt; string()}}
                     | [metric()]
                     | metric().
-type metric()      :: {Name :: string(), Type :: metric_type() }
                     | {Name :: string(), Type :: metric_type(), Opts :: map() }.
-type metric_type() :: counter | gauge | histogram.

-spec initial_state() -&gt; state().
initial_state() -&gt; [].

-spec metrics() -&gt; [graph_group()].
metrics() -&gt; [{group, &quot;Application Metrics&quot;, [
                {graph, #{ title =&gt; &quot;Dummy counter&quot;,
                           units =&gt; &quot;budger&quot;,
                           metrics =&gt; [{&quot;dummy_counter&quot;, counter}]}}
             ]}].

-spec print(state(), meta(), string()) -&gt; {nil, state()}.
print(State, Meta, Text) -&gt;
    mzb_metrics:notify({&quot;dummy_counter&quot;, counter}, 1),
    lager:info(&quot;Printing ~p, Meta: ~p~n&quot;, [Text, Meta]),
    {nil, State}.
</code></pre>

<p>It exports three functions: <code>initial_state/0</code>, <code>metrics/0</code>, and <code>print/3</code>. The first two are mandatory for any worker. </p>
<dl>
<dt><code>initial_state/0</code></dt>
<dd>Set the worker&rsquo;s initial state. Each parallel job has its own state, so this function will be called once per job start.</dd>
<dt><code>metrics/0</code></dt>
<dd>Return a group of metrics generated by this worker. <a href="#how-to-define-metrics">How to define metrics</a>.</dd>
</dl>
<p>The rest of the exported functions define the DSL statements provided by this worker. You can, of course, provide none, although such a worker wouldn&rsquo;t be very useful. The <code>dummy_worker</code>, for instance, provides the <code>print</code> statement to output a string to the standard output. <a href="#how-to-define-statements">How to define statements</a>.</p>
<h2 id="how-to-define-statements">How to Define Statements<a class="headerlink" href="#how-to-define-statements" title="Permanent link">&para;</a></h2>
<p>To define a DSL statement provided by your worker, export an Erlang function that will be called when this statement is encountered:</p>
<pre><code class="erlang">&lt;statement_name&gt;(State, Meta, [&lt;Param1&gt;, [&lt;Param2&gt;, ...]]) -&gt;
    {ReturnValue, NewState}.
</code></pre>

<p>The function has the same name as the statement it defines. It accepts at least two parameters: the worker internal state at the moment the statement is executed and <em>meta</em> information proplist. The function can also accept any number of other parameters. They correspond to the parameters of the statement.</p>
<p>For example, this function:</p>
<pre><code class="erlang">foo(State, Meta, X, Y) -&gt;
    {nil, State}.
</code></pre>

<p>is called as <code>{foo, X, Y}</code> from a benchmarking scenario.</p>
<p>The statement function must return a tuple of two values:</p>
<ul>
<li>the return value of statement; return <code>nil</code> if your statement has no return value</li>
<li>the next worker state</li>
</ul>
<p>Statements are processed sequentially; each statement receives the state from the previous one and passes it further.</p>
<p>Two exceptions are the statements within the <a href="../scenarios/#parallel_1"><code>{parallel}</code></a> section and iterations within a <code>{loop}</code> with <a href="../scenarios/#parallel">parallel &gt; 1</a>. In these cases the statements within the same thread share the same sequence of statements, which parallel threads don&rsquo;t. The final state of the whole <code>{parallel}</code> or <code>{loop}</code> statement is the one from the first &ldquo;thread&rdquo;; other threads&rsquo; states don&rsquo;t affect the final state.</p>
<h2 id="metrics">Metrics<a class="headerlink" href="#metrics" title="Permanent link">&para;</a></h2>
<p>Metrics are numerical values collected during the scenario execution. They are the main result of your worker and represent the values you want to evaluate with your benchmark.</p>
<h3 id="metric-types">Metric Types<a class="headerlink" href="#metric-types" title="Permanent link">&para;</a></h3>
<p>MZBench currently support four types of metrics:</p>
<dl>
<dt><code>counter</code></dt>
<dd>A single additive value. New values are simply added to the current one.</dd>
<dt><code>gauge</code></dt>
<dd>A single non-additive value. New value replaces the previous one.</dd>
<dt><code>histogram</code></dt>
<dd>A set of numerical values that quantify a distribution of values. New values are added to the distribution.</dd>
<dt><code>derived</code></dt>
<dd>Evaluated periodically using user-defined function based on another metric values. <a href="#derived-metrics">Learn more</a>.</dd>
</dl>
<p>For example, if you are consuming TCP packets of various sizes and you want to track overall amount of data being transferred, use <code>counter</code>. If you are interested in its distribution–mean size, 50 percentile, and so on–you need a <code>histogram</code>.</p>
<h3 id="declaring-metrics">Declaring Metrics<a class="headerlink" href="#declaring-metrics" title="Permanent link">&para;</a></h3>
<p>Declare the groups of metrics collected by your worker in the list returned by <code>metrics/0</code>. Each group corresponds to a structure with following spec:</p>
<pre><code>graph_group() :: {group, Name :: string(), [graph()]}
               | graph().
graph()       :: {graph, Opts :: #{metrics =&gt; [metric()],
                                   units =&gt; string(),
                                   title =&gt; string()}}
               | [metric()]
               | metric().
metric()      :: {Name :: string(), Type :: metric_type() }
               | {Name :: string(), Type :: metric_type(), Opts :: map()}.
metric_type() :: counter | gauge | histogram.
</code></pre>

<p>This structure has a three-level hierarchy:</p>
<ul>
<li>Group of graphs is placed on the top of this hierarchy. It consists of one or more graphs and defines a group of graphs under the same name.</li>
<li>Graph consists of one or more metrics that will be plotted on the same chart. Furthermore, you could specify additional options for the chart: units, title, etc.</li>
<li>Metric is the lowest unit of this hierarchy. It specifies the name and type of the user-defined metric.</li>
</ul>
<p>Let&rsquo;s see the following metrics declaration:</p>
<pre><code>metrics() -&gt; [{group, &quot;HTTP Requests&quot;, [
                {graph, #{metrics =&gt; [{&quot;success_requests&quot;, counter}, {&quot;failed_requests&quot;, counter}]}},
                {graph, #{title =&gt; &quot;Request's latency&quot;,
                          units =&gt; &quot;ms&quot;,
                          metrics =&gt; [{&quot;latency&quot;, histogram}]}}]}].
</code></pre>

<p>In this example, a group of graphs with the name &ldquo;HTTP Requests&rdquo; is created. It consists of several graphs representing the number of successful and failed requests and the request latencies.</p>
<p>A graph can produce several charts. In the example above, the graph for successful and failed request produces two charts: absolute counters and their rps.</p>
<h3 id="derived-metrics">Derived Metrics<a class="headerlink" href="#derived-metrics" title="Permanent link">&para;</a></h3>
<p>Derived metrics are basically gauges which are evaluated on the director node every ~10sec. To define a derived metric, specify the <code>resolver</code> function in the metric opts dictionary. This function is used to evaluate the metric value.</p>
<p>Typical example of a derived metric is the current number of pending requests. We specify a function (<code>pending_requests</code>) to calculate the metric value in the metric options and then define the function as simple difference between the number of sent requests and received responses:</p>
<pre><code class="erlang">metrics() -&gt; [{group, &quot;Requests&quot;, [
                {graph, #{metrics =&gt; [
                    {&quot;requests_sent&quot;, counter},
                    {&quot;responses_received&quot;, counter},
                    {&quot;pending_requests&quot;, derived, #{resolver =&gt; pending_requests}}]}},
                ]}].

pending_requests() -&gt;
    mzb_metrics:get_value(&quot;requests_sent&quot;) - mzb_metrics:get_value(&quot;responses_received&quot;).
</code></pre>

<h3 id="hooks">Hooks<a class="headerlink" href="#hooks" title="Permanent link">&para;</a></h3>
<p><a href="../scenarios/#pre_hook-and-post_hook">Pre and post hooks</a> let you run custom code before and after a benchmark. Hooks can be applied on every node or only on the director node. You can change any environment variable in your hook handler and use it in your scenario.</p>
<p>Scenario:</p>
<pre><code class="erlang">{pre_hook, [
    {exec, all, &quot;yum install zlib&quot;},
    {worker_call, fetch_commit, my_worker}
]}

{pool, [{size, 3}, {worker_type, dummy_worker}], [
    {loop, [{time, {1, sec}},
            {rate, {ramp, linear, {10, rps}, {50, rps}}}],
        [{print, {var, &quot;commit&quot;, &quot;default&quot;}}]}]},
</code></pre>

<p>Worker:</p>
<pre><code class="erlang">fetch_commit(Env) -&gt;
    {ok, [{&quot;commit&quot;, &quot;0123456&quot;} | Env]}.
</code></pre>

<h3 id="updating-metrics">Updating Metrics<a class="headerlink" href="#updating-metrics" title="Permanent link">&para;</a></h3>
<p>You can update a metric from anywhere inside your worker. Simply call the following function:</p>
<pre><code class="erlang">mzb_metrics:notify({&quot;&lt;metric_name&gt;&quot;, &lt;metric_type&gt;}, &lt;value&gt;)
</code></pre>

<p>The tuple <code>{"&lt;metric_name&gt;", &lt;metric_type&gt;}</code> is the same that was used during the metric declaration and identifies the metric to update. <code>&lt;value&gt;</code> is the value to add to the metric.</p></div>
            
        </div>

        <footer class="col-md-12">
            <hr>
            
            <p>Documentation built with <a href="http://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>

        <script src="../js/jquery-1.10.2.min.js"></script>
        <script src="../js/bootstrap-3.0.3.min.js"></script>
        <script src="../js/highlight.pack.js"></script>
        <script>var base_url = '..';</script>
        <script data-main="../mkdocs/js/search.js" src="../mkdocs/js/require.js"></script>
        <script src="../js/base.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                        <h4 class="modal-title" id="exampleModalLabel">Search</h4>
                    </div>
                    <div class="modal-body">
                        <p>
                            From here you can search these documents. Enter
                            your search terms below.
                        </p>
                        <form role="form">
                            <div class="form-group">
                                <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query">
                            </div>
                        </form>
                        <div id="mkdocs-search-results"></div>
                    </div>
                    <div class="modal-footer">
                    </div>
                </div>
            </div>
        </div>

    </body>
</html>
